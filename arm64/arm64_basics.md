# arm64 basics 

### регистры
`x0 - x30 SP PC (64 бит) - каждый имеет 32-битную версию w0 – w30 (нижние 32 бита соответствующего x-регистра).`<br>
`X0–X7 - аргументы функции / возвращаемые значения (X0 — основной)`<br>
X8 — временный / indirect result / ABI-dependent (часто используется как scratch).<br>
X16, X17 — IP0/IP1; используются для вызовов через plt/pc-rel (thunks), компилятор/линкер часто помещают туда адреса для blr x17.<br>
X18 — platform register (по соглашению, может быть reserved).<br>
X19–X28 — callee-saved (должны быть сохранены вызываемой функцией, если используются).<br>
`X29 (FP) - frame pointer. обычно указывает на базу текущего фрейма стека (фиксированная точка в кадре), используется для доступа к локальным переменным и для построения цепочки кадров. (где начинается стек текущей функции)`<br>
`X30 (LP) - Link Pointer - хранит адрес возврата (куда прыгнуть после конца выполнения функции (если она не no-return))`<br>
`SP - Stack Pointer - указывает на адрес начала стека(вершина стека). (типо куда щас можно писать на стеке, см. схему ниже)`<br>
`PC - program counter (адрес текущей инструкции).`<br><br><br>





### стек (растет вниз) (тут для удобства наоборот - вершина стека внизу и адреса растут вверх, в реальности все наоборот)
```
адреса ↑
───────────────────────
0x1000   ←  старые данные 9 (4096)
0x0FF0   (4080)
0x0FE0   (4064)
0x0FD0   ←  SP (вершина стека) (4048)
───────────────────────
адреса ↓
```
делаем
```asm
sub sp, sp, #0x10   ; освободили 16 байт под новые данные
str x0, [sp]        ; записали что-то на вершину
```
Теперь SP = 0x0FC0, а данные лежат в диапазоне [0x0FC0–0x0FD0).<br>
```
ldr x0, [sp]
add sp, sp, #0x10   ; убрали 16 байт
```
— стек "сжимается вверх", и SP снова указывает на 0x0FD0.<br><br>
`Вершина стека (SP) — это тарелка, к которой ты сейчас можешь дотронуться (верхняя).`<br>
`Но память идёт сверху вниз — то есть каждая новая тарелка кладётся ниже предыдущей в адресах.`
```
       ↑  большие адреса
       │
       │        (старые данные)
0x1000 ──────────────────────────────
       │
       │   ← старый SP (верх стека)
0x0FF0 ──────────────────────────────
       │
       │   PUSH (новая тарелка):
       │   sub sp, sp, #0x10
       │   теперь SP указывает ниже!
0x0FE0 ──────────────────────────────  ← новый SP (вершина стека)
       │        (новые данные)
       │
       ↓  меньшие адреса
```
В реальной памяти адреса растут вниз по экрану (в сторону увеличения значений).<br>
В стеке ARM64 всё наоборот: при push адрес уменьшается,
потому что стек "растёт вниз" (в сторону меньших адресов).<br>
# Безусловный переход — B и BL

b loop_start      ; перейти на метку loop_start
- Не сохраняет адрес возврата.<br><br>

BL <label> — Branch with Link<br>
Прыжок с сохранением адреса возврата в X30 (LR)<br>
bl printf          ; вызвать функцию printf<br>
Сохраняет адрес следующей инструкции в LR.<br>
После завершения функции — возврат через ret, который использует LR.<br>

```
     +--------------------+
     | caller (main)      |
     | ...                |
     | bl func ---------->+--+
     +--------------------+  |
                             |
                             v
                   +----------------------+
                   | callee (func)        |
                   | LR = return addr  <--+
                   | ...                  |
                   | ret                  |
                   +----------------------+
                            |
                            v
                 возвращаемся в main (LR)
```



## RET
Возврат по адресу, который лежит в X30 (LR) или другом регистре.<br>
ret             ; по умолчанию ret x30<br>
ret x19         ; возврат по адресу в x19<br>

## Условные переходы — B.<cond>
Прыжок выполняется только если условие (флаг в PSTATE) истинно.
```
| Сокращение | Значение                    | Проверяет         |
| ---------- | --------------------------- | ----------------- |
| `eq`       | equal                       | Z == 1            |
| `ne`       | not equal                   | Z == 0            |
| `lt`       | less than (signed)          | N != V            |
| `le`       | less or equal (signed)      | Z == 1 or N != V  |
| `gt`       | greater than (signed)       | Z == 0 and N == V |
| `ge`       | greater or equal (signed)   | N == V            |
| `lo`       | lower (unsigned <)          | C == 0            |
| `ls`       | lower or same (unsigned ≤)  | C == 0 or Z == 1  |
| `hi`       | higher (unsigned >)         | C == 1 and Z == 0 |
| `hs`       | higher or same (unsigned ≥) | C == 1            |
| `mi`       | minus                       | N == 1            |
| `pl`       | plus                        | N == 0            |
| `vs`       | overflow set                | V == 1            |
| `vc`       | overflow clear              | V == 0            |
| `al`       | always (эквивалент `b`)     | всегда прыгает    |
```
<br>

```
cmp x0, #0
b.eq zero_case      ; если x0 == 0
b.ne non_zero_case  ; если x0 != 0
```

```
| Флаг  | Назначение | Устанавливается чем                      |
| ----- | ---------- | ---------------------------------------- |
| **N** | Negative   | результат < 0                            |
| **Z** | Zero       | результат == 0                           |
| **C** | Carry      | перенос в арифм. операциях (беззнаковое) |
| **V** | Overflow   | переполнение (знаковое)                  |
```

```
cmp x0, #5     ; вычитание x0 - 5
b.ge label     ; если x0 >= 5 (N == V)
```

# Переходы по регистру — BR, BLR
Используются для переходов по адресу, хранящемуся в регистре (аналог jmp rax в x86).<br>
BR <Xt> - Переход без сохранения возврата.<br>
```
mov x1, #0x1000
br x1              ; перейти на 0x1000
```
<br>
BLR <Xt> - Переход с сохранением возврата (аналог call rax).<br>
       
```
mov x17, #func
blr x17            ; вызвать функцию по адресу в x17
```
<br>  
Сохраняет адрес возврата в LR (x30).<br> 
Используется для вызовов через таблицы PLT/GOT и виртуальные функции.<br><br> 

RET — возвращается по адресу в X30 (LR) (по умолчанию)<br>
RET <Xt> — возвращается по адресу из любого регистра (используется в обфускации или trampolines)<br>
<br>
```
cbz x0, zero_case      ; если x0 == 0
cbnz x0, not_zero      ; если x0 != 0
tbz x1, #2, bit_clear  ; если бит 2 = 0
tbnz x1, #2, bit_set   ; если бит 2 = 1
```

```
| Инструкция             | Значение                        | Что делает                   |
| ---------------------- | ------------------------------- | ---------------------------- |
| `cbz Xt, label`        | Compare and Branch if Zero      | Переход, если регистр == 0   |
| `cbnz Xt, label`       | Compare and Branch if Not Zero  | Переход, если регистр != 0   |
| `tbz Xt, #bit, label`  | Test Bit and Branch if Zero     | Переход, если бит сброшен    |
| `tbnz Xt, #bit, label` | Test Bit and Branch if Non-Zero | Переход, если бит установлен |
```
<br><br>
```
adrp x0, some_label@page
add  x0, x0, some_label@pageoff
bl   puts
```
<br>
adr — помещает текущий PC + смещение (до ±1 МБ) в регистр.<br>
adrp — то же самое, но по страницам (на 4К шаг, ±4 ГБ от PC).<br>
Вместе с add позволяют получить абсолютный адрес символа, не используя ldr.<br>

<br><br>
